<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model with Three.js</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
        // Initialize the scene
        const scene = new THREE.Scene();

        // Set up the camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;

        // Set up the renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Function to create a cube group with mesh and wireframe
        function createCubeGroup(position, color) {
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshBasicMaterial({ color });
            const cube = new THREE.Mesh(geometry, material);
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);

            const cubeGroup = new THREE.Object3D();
            cubeGroup.add(cube);
            cubeGroup.add(wireframe);
            cubeGroup.position.copy(position);

            return cubeGroup;
        }

        // Create initial cube
        const initialCubeGroup = createCubeGroup(new THREE.Vector3(), 0x00ff00);
        scene.add(initialCubeGroup);

        // Add OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Array to keep track of cube groups
        const cubes = [initialCubeGroup];
        const directions = [
            { x: 1, y: 0, z: 0 },
            { x: -1, y: 0, z: 0 },
            { x: 0, y: 1, z: 0 },
            { x: 0, y: -1, z: 0 },
            { x: 0, y: 0, z: 1 },
            { x: 0, y: 0, z: -1 }
        ];

        // Function to create a new cube group with random color at an available position
        function createCube() {
            const color = Math.random() * 0xffffff;
            let positionFound = false;
            let newPosition = new THREE.Vector3();

            for (let i = 0; i < cubes.length && !positionFound; i++) {
                const basePosition = cubes[i].position;
                for (const direction of directions) {
                    newPosition.set(
                        basePosition.x + direction.x * 2,
                        basePosition.y + direction.y * 2,
                        basePosition.z + direction.z * 2
                    );
                    const overlap = cubes.some(c => c.position.equals(newPosition));
                    if (!overlap) {
                        positionFound = true;
                        break;
                    }
                }
            }

            if (positionFound) {
                const newCubeGroup = createCubeGroup(newPosition, color);
                scene.add(newCubeGroup);
                cubes.push(newCubeGroup);
            }
        }

        // Event listener for keydown
        document.addEventListener('keydown', (event) => {
            if (event.key === 'a') {
                createCube();  // Add one cube
            } else if (event.key === 'd') {
                console.log('D key pressed');
                triggerWave();
            }
        });

        // Function to trigger a wave effect with continuous motion in random directions
        function triggerWave() {
            console.log('Wave triggered');
            cubes.forEach((cube, index) => {
                const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                const animateCube = () => {
                    const newPos = {
                        x: cube.position.x + randomDirection.x * 0.1,
                        y: cube.position.y + randomDirection.y * 0.1,
                        z: cube.position.z + randomDirection.z * 0.1
                    };
                    new TWEEN.Tween(cube.position)
                        .to(newPos, 100)
                        .easing(TWEEN.Easing.Linear.None)
                        .onComplete(animateCube)
                        .start();
                };
                setTimeout(animateCube, index * 100);
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update controls
            controls.update();

            // Update tweens
            TWEEN.update();

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
