<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model with Three.js</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="controls">
        <label for="forceRange">Force:</label>
        <input type="range" id="forceRange" name="forceRange" min="1" max="30" value="10">
        <span id="forceValue">10x</span>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
        // Initialize the scene
        const scene = new THREE.Scene();

        // Set up the camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;

        // Set up the renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Get the force range input and display element
        const forceRange = document.getElementById('forceRange');
        const forceValue = document.getElementById('forceValue');
        let forceMultiplier = parseInt(forceRange.value, 10);

        // Initialize the force value display
        forceValue.textContent = `${forceMultiplier}x`;

        // Update the force value display
        forceRange.addEventListener('input', () => {
            forceMultiplier = parseInt(forceRange.value, 10);
            forceValue.textContent = `${forceMultiplier}x`;
        });

        // Function to create a cube group with mesh and wireframe
        function createCubeGroup(position, color) {
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshBasicMaterial({ color });
            const cube = new THREE.Mesh(geometry, material);
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);

            const cubeGroup = new THREE.Object3D();
            cubeGroup.add(cube);
            cubeGroup.add(wireframe);
            cubeGroup.position.copy(position);
            cubeGroup.moved = false; // Add a property to track if the cube has been moved

            return cubeGroup;
        }

        // Create initial cube
        const initialCubeGroup = createCubeGroup(new THREE.Vector3(), 0x00ff00);
        scene.add(initialCubeGroup);

        // Add OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Array to keep track of cube groups
        const cubes = [initialCubeGroup];

        // Function to create a new cube group with random color at an available position
        function createCube() {
            const color = Math.random() * 0xffffff;
            let positionFound = false;
            let newPosition = new THREE.Vector3();

            for (let i = 0; i < cubes.length && !positionFound; i++) {
                const basePosition = cubes[i].position;
                for (let j = 0; j < 100; j++) { // Try 100 random positions
                    newPosition.set(
                        basePosition.x + (Math.random() - 0.5) * 4,
                        basePosition.y + (Math.random() - 0.5) * 4,
                        basePosition.z + (Math.random() - 0.5) * 4
                    );
                    const overlap = cubes.some(c => c.position.distanceTo(newPosition) < 2);
                    if (!overlap) {
                        positionFound = true;
                        break;
                    }
                }
            }

            if (positionFound) {
                const newCubeGroup = createCubeGroup(newPosition, color);
                scene.add(newCubeGroup);
                cubes.push(newCubeGroup);
            }
        }

        // Event listener for keydown
        document.addEventListener('keydown', (event) => {
            if (event.key === 'a') {
                createCube();  // Add one cube
            } else if (event.key === 'd') {
                console.log('D key pressed');
                triggerWave();
            }
        });

        // Function to generate a random direction vector
        function getRandomDirection() {
            const vector = new THREE.Vector3(
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
            );
            vector.normalize(); // Normalize to get a unit vector
            return vector;
        }

        // Function to trigger a wave effect with continuous motion in random directions
        function triggerWave() {
            console.log('Wave triggered');
            const delay = 100 / forceMultiplier; // Decrease delay by force multiplier to speed up the ripple
            cubes.forEach((cube, index) => {
                if (!cube.moved) { // Only move cubes that haven't been moved yet
                    const randomDirection = getRandomDirection();
                    const cubeForceMultiplier = forceMultiplier; // Capture the force multiplier at the time of movement
                    const animateCube = () => {
                        const newPos = {
                            x: cube.position.x + randomDirection.x * 0.1 * (cubeForceMultiplier / 20 * 10),
                            y: cube.position.y + randomDirection.y * 0.1 * (cubeForceMultiplier / 20 * 10),
                            z: cube.position.z + randomDirection.z * 0.1 * (cubeForceMultiplier / 20 * 10)
                        };
                        new TWEEN.Tween(cube.position)
                            .to(newPos, 100)
                            .easing(TWEEN.Easing.Linear.None)
                            .onComplete(animateCube)
                            .start();
                    };
                    setTimeout(animateCube, index * delay);
                    cube.moved = true; // Mark the cube as moved
                }
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update controls
            controls.update();

            // Update tweens
            TWEEN.update();

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
